---
title: Quick Start
description: The fastest and simplest way to start using Takumi.
icon: Axe
---

Takumi is an **image rendering engine** written in Rust. The design is mainly inspired by [satori](https://github.com/vercel/satori), but with a focus on portability and performance (2-10x shown in [Image Bench](https://image-bench.kane.tw/)).

You can try Takumi in [Playground](/playground) without any installation.

## Installation

The fastest/simplest way to use Takumi is with the `ImageResponse` API. It handles the internal state for font & image cache and it tries to be compatible with [Next.js ImageResponse API](https://nextjs.org/docs/app/api-reference/functions/image-response).

```npm
npm i @takumi-rs/image-response
```

### Additional Bundler Setup

Takumi offers two types of bindings for different environments. [`@takumi-rs/core`](https://www.npmjs.com/package/@takumi-rs/core) for Node.js and [`@takumi-rs/wasm`](https://www.npmjs.com/package/@takumi-rs/wasm) for WebAssembly.

#### Node.js Runtime

<Accordions type="single">
  <Accordion title="Next.js">

By default Next.js bundles the `@takumi-rs/core` package, which requires native Node.js `require` function to resolve the native binary. You need to opt-out from the bundling by setting the `serverExternalPackages` option.

```ts title="next.config.ts"
export const config = {
  serverExternalPackages: ["@takumi-rs/image-response"],
};
```
  </Accordion>
  <Accordion title="Vite (SSR)">
Opt-out from the bundling by setting the `ssr.external` and `optimizeDeps.exclude` options.

```ts title="vite.config.ts"
export default defineConfig({
  ssr: {
    external: ["@takumi-rs/image-response"],
  },
  optimizeDeps: {
    exclude: ["@takumi-rs/image-response"],
  },
});
```
  </Accordion>
</Accordions>

#### Edge Runtime / Browser

First the wasm package needs to be installed separately. Make sure both `@takumi-rs/image-response` and `@takumi-rs/wasm` have the same version.

```npm
npm i @takumi-rs/wasm
```

<Accordions type="single">
  <Accordion title="Cloudflare Workers">
Wrangler's bundling process handles the wasm initialization for you by default, you can just load it in synchronous way.

```ts
import ImageResponse from "@takumi-rs/image-response/wasm";
import { initSync } from "@takumi-rs/wasm";
import module from "@takumi-rs/wasm/takumi_wasm_bg.wasm";

initSync({ module });

// ...
```

Check the [example project](https://github.com/kane50613/takumi/tree/master/example/cloudflare-workers) with wrangler usage.
  </Accordion>
  <Accordion title="Vite">
Load the WASM file as an asset.

```tsx
import init from "@takumi-rs/wasm";
import wasmUrl from "@takumi-rs/wasm/takumi_wasm_bg.wasm?url";

await init(wasmUrl);

// ...
```
  </Accordion>
  <Accordion title="Next.js Edge Runtime (Turbopack)">
As of the time of writing, there's no support for asset loader like how Webpack used to do. The Node.js approach mentioned above is recommended instead.

Read more in [vercel/next.js #75430](https://github.com/vercel/next.js/discussions/75430).
  </Accordion>
  <Accordion title="Webpack">
First, configure Webpack to recognize the WASM file as an asset.

```js title="webpack.config.js"
module.exports = {
  module: {
    rules: [
      {
        test: /\.wasm$/,
        type: 'asset/resource',
        generator: {
          filename: 'wasm/[name].[hash][ext]'
        }
      }
    ]
  }
};
```

Then, in your code, import the WASM file and initialize the module:

```js
import init, { Renderer } from '@takumi-rs/wasm';
import wasmUrl from '@takumi-rs/wasm/takumi_wasm_bg.wasm';

await init(wasmUrl);
const renderer = new Renderer();
```
  </Accordion>
</Accordions>



## Usage

Since `ImageResponse` extends standard [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) class, you can plug it into anywhere you want.

It comes with pre-bundled full axis (which means 100-900 weights available) [Geist](https://vercel.com/font) and Geist Mono as default fonts. [Tailwind CSS](https://tailwindcss.com/) is also supported out of the box.

<Tabs items={["Node.js", "WASM"]}>
<Tab>
```tsx
import { ImageResponse } from "@takumi-rs/image-response";
import { serve } from "bun";

serve({
  fetch() {
    return new ImageResponse(<Hello />, {
      width: 1200,
      height: 630,
      format: "webp",
    });
  },
});

function Hello() {
  return (
    <div tw="bg-white w-full h-full flex items-center justify-center">
      <h1 tw="text-4xl font-bold">Hello</h1>
    </div>
  );
}
```
</Tab>
<Tab>
```tsx
import { ImageResponse } from "@takumi-rs/image-response/wasm";
import init from "@takumi-rs/wasm";
import { serve } from "bun";

// the wasm module has to be initialized before using the ImageResponse API
await init({
  // or with bundler magic like ?url to resolve the wasm file path
  module_or_path: fetch(
    import.meta.resolve("@takumi-rs/wasm/takumi_wasm_bg.wasm"),
  ),
});

export default {
  fetch() {
    return new ImageResponse(<Hello />, {
      width: 1200,
      height: 630,
      format: "webp",
    });
  },
}
```
</Tab>
</Tabs>

### Templates

If you don't have any idea about where to start, or just want quick and easy way to get started, you can use the built-in templates.

```npm
npm i @takumi-rs/template
```

```tsx
import DocsTemplateV1 from "@takumi-rs/template/docs-template-v1";
import { ImageResponse } from "@takumi-rs/image-response";
import { Axe } from "lucide-react";

export function GET() {
  return new ImageResponse(
    <DocsTemplateV1 
      title="Hello" 
      description="World" 
      icon={<Axe />} 
      primaryColor="hsla(354, 90%, 54%, 0.3)" 
      primaryTextColor="hsl(354, 90%, 60%)" 
      site="Takumi" 
    />, 
    {
      width: 1200,
      height: 630,
      format: "webp",
    },
  );
}
```

You can find all the templates in the [`takumi-template` folder](https://github.com/kane50613/takumi/tree/master/takumi-template/src/templates).

We need your help to improve and create more templates! Please feel free to submit PRs to add more templates.

## Examples

Check out the [`example` folder](https://github.com/kane50613/takumi/tree/master/example) for different framework usages.

## Learn More

### Why build a satori alternative?

Takumi's focus is on how to rasterize images fast, while satori outputs SVG.

<Callout type="info">
More discussion can be found in [this X thread by @shuding_](https://x.com/shuding_/status/1958853749004542445).
</Callout>

- All in one. No need to output SVG then have [resvg-js](https://github.com/thx/resvg-js) rendering it again to output PNG.
- Inline layout support (display `block` or `inline`).
- Tailwind CSS support out of the box.
- RTL support.
- Variable fonts support.
- WOFF2 font format support.
- PNG, JPEG, WebP, AVIF output support.
- WebP, APNG animation rendering support.
